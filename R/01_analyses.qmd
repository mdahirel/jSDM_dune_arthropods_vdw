---
title: "01 - analyses"
format: html
editor_options: 
  chunk_output_type: console
---

```{r load-packages}
library(ape)
library(coda)
library(conflicted)
library(datawizard)
library(ggcorrplot)
library(ggtext)
library(ggtree)
library(Hmsc)
library(ncf)
library(patchwork)
library(phytools)
library(posterior)
library(tidybayes)
library(tidyverse)

library(here)
```

```{r load-custom-functions}
HMSCfunctions <- list.files(here("R", "tidyHMSC"), pattern = "*.R")

for (i in 1:length(HMSCfunctions)) {
  source(here("R", "tidyHMSC", HMSCfunctions[i]))
}
```

```{r solve-conflicts}
conflict_scout()
conflicted::conflict_prefer_all("purrr", quiet = TRUE) # avoid a map() conflict with a dependency of phytools
conflicted::conflict_prefer_all("dplyr", quiet = TRUE)
```


# Part 1: Formatting datasets for analyses

```{r load-raw-data}
raw_community <- read_csv(here("data", "Y_long_community.csv"))
raw_trait_data <- read_csv(here("data", "traits.csv"))
raw_envt <- read_csv(here("data", "data_vars.csv"))
raw_tree <- read.tree(here("data", "trees", "tree_relabeled_with_singletons.newick"))
```

## Tree data

Note how the tree reimported from the newick file has underscores instead of spaces between genus and species?

```{r check-tree-tip-names}
raw_tree$tip.label
```

We're leaving that as is **for now** (easier for managing species names as column names in species occurrence data table), so we will need to add the underscores to the species names in both occurrence and trait tables.

- The saved tree has a lot of singletons nodes from the Open Tree of Life. Basically it's all larger clade names from which we pruned all branches but one in the making of our subtree. Since the root of our tree is at the common ancestor of arthropods and molluscs, there can be a lot of these. We kept them in the saved file because they helped make a pretty annotated tree plot, but we need to remove them for the actual analysis here as they may mess up branch length calculations
- Then we add branch length to the OTOL tree. We do that using Grafen's method (see `?compute.brlen()` for reference)

```{r tree-branch-lengths}
phylotree <- raw_tree |>
  collapse.singles() |>
  compute.brlen(method = "Grafen")
```

## Community data

Then we manage the community data:

- we add underscores to `species` names
- we sort data by alphabetical order of species and sites
- we pivot the data to the wide format, one species = one column
- finally, we convert the community data to a matrix, with `sampleID` as row names

```{r make-YData}
community_wide <- raw_community |>
  mutate(species = str_replace_all(species, " ", "_")) |>
  arrange(sample_ID, species) |>
  pivot_wider(names_from = species, values_from = presence)

YData <- community_wide |>
  select(-sample_ID) |>
  as.matrix()

row.names(YData) <- community_wide$sample_ID
# hist(colMeans(YData),50)
```

## Trait data

Now let's move to formatting trait data.
We do a few things:

- first, we add underscores in the `species` names, again
- then we sort species by names
- we create a log10(size) variable
- we scale the continuous variables (size here) to mean 0 and unit 1SD. Strictly speaking not needed, as `Hmsc()` does it internally as a default, but see **Environmental data** below for why it's helpful to do it manually
- we also convert the trophic level variables to factors, and reorder these factors so that the dominant trophic level (herbivore, see below) is the factor reference level
- we finish by moving species names to the data.frame row names

```{r checking-trophic-levels}
table(raw_trait_data$trophic_level_adult)
table(raw_trait_data$trophic_level_larva)
```

```{r make-TrData}
TrData <- raw_trait_data |>
  mutate(species = str_replace_all(species, " ", "_")) |>
  arrange(species) |>
  mutate(log10size = log(size_mm, 10)) |>
  standardize(append = "_scaled") |>
  mutate(trophic_level_adult = fct_relevel(
    trophic_level_adult,
    c("Herbivore", "Predator", "Detritivore", "Omnivore")
  )) |>
  mutate(trophic_level_larva = fct_relevel(
    trophic_level_larva,
    c("Herbivore", "Predator", "Detritivore", "Omnivore")
  )) |>
  as.data.frame()

row.names(TrData) <- TrData$species
```

## Environmental data

```{r check-vitality}
table(raw_envt$vitality)
```

There are 5 vitality levels, but there is only 1 zero value and very few 1 values. In first analyses, vitality was used to fit a continuous quadratic effect. Given the limited range of values and the fact that there are almost no low values, this seems ill-advised. So, if we do want to allow for non-linear effects of vitality, the best solution in my opinion is to use it as a factor. Given there is only 1 zero value, it is also best to pool it with the 1s as "low vitality".

```{r check-districts}
table(raw_envt$district)
```

So, to make the environmental data table:

- we convert vitality values to a factor, with the 0 and 1 pooled. We set highest vitality as the reference level
- we set the district with the most samples (Flemish dunes) as the reference level for `district`, converted to factor
- we scale continuous variables. This has usually two benefits (i) improves Bayesian model fitting performance (ii) makes effects of different variables comparable to each other. As mentioned above, not strictly needed for (i), since `Hmsc()` can do it internally, but `Hmsc()` backtransforms coefficients to original scales in its outputs, so for (ii) we do need to scale variables ourselves)

```{r make-XData}
XData <- raw_envt |>
  arrange(sample_ID) |>
  mutate(vitalityF = case_when(
    vitality < 2 ~ "0_1",
    TRUE ~ as.character(vitality)
  ), .after = vitality) |>
  mutate(vitalityF = fct_relevel(vitalityF, c("4", "3", "2", "0_1"))) |>
  mutate(district = fct_relevel(district, "Flemish dunes", after = 0)) |>
  standardize(append = "_scaled") |>
  mutate(dupe = duplicated(data.frame(X, Y))) |> # 2 samples have same coordinates as 2 other (presumably nearby)
  mutate(
    sample_ID = factor(sample_ID),
    transect = factor(transect),
    country = factor(country)
  ) |> # Hmsc() doesn't like variables as character in this dataframe, even if not used in formula
  as.data.frame()

row.names(XData) <- XData$sample_ID
```

## Final checks

```{r final-data-checks}
levels(factor(XData$district))
levels(factor(XData$vitalityF))
table(rownames(YData) == rownames(XData))
table(rownames(TrData) == colnames(YData))
# everything is properly re-ordered
```

we're ready to make our model, following what's written in the Methods of the main text

# Part 2: the model

## Model formulas

```{r XFormula}
XFormula <- ~ vitalityF + district +
  proportion_50_scaled + I(proportion_50_scaled^2) + mt_stat_50_scaled
```
Since we centred our continuous variables, we are "allowed" to build our quadratic effects "manually" (see Schielzeth 2010 MEE, DOI:10.1111/j.2041-210X.2010.00012.x). Compared to using `poly()`, this will make it easier to interpret them a bit, but more importantly will reduce the need for name cleaning when doing plots later.

```{r TrFormula}
TrFormula <- ~ trophic_level_adult + log10size_scaled
```

## Making the model

```{r random-effects-structure}
studyDesign <- XData |> select(sample_ID)
rSample <- HmscRandomLevel(units = XData$sample_ID) |>
  setPriors(a1 = 60, a2 = 60)
```

The default prior values for `a1` and `a2` are both 50 (see `str(rSample)` before `setPriors()`), setting them higher makes for emptier correlations (stronger shrinkage), see HMSC book. Models with prior values of 50 have major difficulties to converge with this model's structure and our data.

```{r model_full}
if (file.exists(here("models", "mfull.RDS"))) {
  mfull <- readRDS(here("models", "mfull.RDS"))
} else {
  starttime <- Sys.time()

  mfull <- Hmsc(
    Y = YData,
    XData = XData,
    XFormula = XFormula,
    TrData = TrData,
    TrFormula = TrFormula,
    phyloTree = phylotree,
    studyDesign = studyDesign,
    ranLevels = list("sample_ID" = rSample),
    distr = "probit"
  )

  set.seed(42)
  mfull <- sampleMcmc(mfull,
    nChains = 4,
    thin = 30,
    samples = 1000,
    transient = 15000,
    nParallel = 4
  )
  saveRDS(mfull, file = here("models", "mfull.RDS"))

  endtime <- Sys.time()
  endtime - starttime
}
## model takes about 5 hours to run
```

## Basic model diagnostics

```{r HSMCsummary}
summary.mfull <- HMSCsummary(mfull)
```

```{r splot-diags}
summary_relettered <- summary.mfull |>
  mutate(fixed_or_random = case_when(
    parameter_type %in% c("Beta", "V", "Rho", "Gamma") ~ "fixed effects (L^F^)",
    parameter_type %in% c("Alpha", "Delta", "Eta", "Lambda", "Omega", "Psi") ~ "random effects (L^R^)",
    TRUE ~ "&Sigma;"
  )) |>
  mutate(
    parameter_type = case_when(
      parameter_type %in% c("Beta", "Delta", "Rho") ~
        paste0("&", str_to_lower(parameter_type), ";"),
      parameter_type == "Psi" ~
        "&Phi;", # what is named as Psi in code seems to be Phi in book, TBC
      parameter_type %in% c("Eta", "Gamma", "Lambda", "Omega", "Sigma", "Alpha") ~
        paste0("&", parameter_type, ";"),
      TRUE ~ parameter_type
    ) # V is the only type with a Roman letter
  )


p_bulk <- summary_relettered |> filter(!is.na(ess_bulk)) |> # slot sigma is NA for probit models
  ggplot() +
  geom_boxplot(aes(parameter_type, ess_bulk)) +
  geom_hline(yintercept = 400, linetype = 2) +
  scale_x_discrete("Parameter type") +
  scale_y_continuous("*ESS<sub>bulk</sub>*", limits = c(0, 5000)) +
  facet_grid(cols = vars(fixed_or_random), scales = "free_x", space = "free_x")

p_tail <- summary_relettered |>
  filter(!is.na(ess_tail)) |>
  ggplot() +
  geom_boxplot(aes(parameter_type, ess_tail)) +
  geom_hline(yintercept = 400, linetype = 2) +
  scale_x_discrete("Parameter type") +
  scale_y_continuous("*ESS<sub>tail</sub>*", limits = c(0, 5000)) +
  facet_grid(cols = vars(fixed_or_random), scales = "free_x", space = "free_x")

p_rhat <- summary_relettered |>
  filter(!is.na(rhat)) |>
  ggplot() +
  geom_boxplot(aes(parameter_type, rhat)) +
  geom_hline(yintercept = 1.01, linetype = 2) +
  scale_x_discrete("Parameter type") +
  scale_y_continuous("*R&#770;*", limits = c(0.998, 1.012)) +
  facet_grid(cols = vars(fixed_or_random), scales = "free_x", space = "free_x")


p_diag <- (
  (p_bulk / p_tail / p_rhat) &
    theme_bw() &
    theme(
      axis.text.x = element_markdown(),
      axis.text.y = element_markdown(),
      strip.text = element_markdown(),
      title = element_markdown(),
    )
) +
  plot_layout(axis_titles = "collect")
```


```{r save-splots-diags}
ggsave(filename = here("plots", "Splot_model_diagnostics.pdf"), plot = p_diag, device = cairo_pdf, width = 6, height = 8)
```

# Part 3: model results

```{r tree-for-plots}
tree_for_plot <- mfull$phyloTree

tree_for_plot$tip.label <- paste0("*", mfull$phyloTree$tip.label, "*") |>
  str_replace("_", " ")

p_tree <- ggtree(tree_for_plot)
```

```{r fitted-values}
fits_mfull <- HMSCfitted(mfull)
```

## 3A - Getting some information about predicted species occurrence


```{r HMSCoccurrence}
occ_mfull <- HMSCoccurrence(fits_mfull)
occ_mfull$occ
occ_mfull$occ_avg
```

## 3B - cross-validation and model performance

### creating cross-validated predictions

As a trade-off between running time and need to have more folds, we use 4-fold cross-validation

```{r making-CVpreds}
if (file.exists(here("models", "fits_CVfull.RDS"))) {
  fits_CVfull <- readRDS(here("models", "fits_CVfull.RDS"))
} else {
  starttime <- Sys.time()

  set.seed(42)
  partition <- createPartition(mfull, nfolds = 4, column = "sample_ID")
  preds_CVfull <- computePredictedValues(mfull, partition = partition, nParallel = 4)

  attr(preds_CVfull, "HMSCcrossval") <- TRUE

  fits_CVfull <- HMSCfitted_CV(mfull, preds_CVfull)

  saveRDS(fits_CVfull, file = here("models", "fits_CVfull.RDS"))

  endtime <- Sys.time()
  endtime - starttime
}
```

### model performance metrics

We compute out-of-sample model performance metrics on the *cross-validated* predictions
```{r perf-metrics}
tjur_CVfull <- HMSCtjurD(fits_CVfull)
PRAUC_CVfull <- HMSCauc(fits_CVfull,auc_type="PR")
```

```{r check-tjur}
tjur_CVfull$tjurD_avg
```

```{r perfplot}
fitmetrics <- tjur_CVfull$tjurD_per_species |> 
  select(species, TjurD, D.lower=.lower,D.upper=.upper) |> 
  left_join(
    PRAUC_CVfull$AUC_per_species|> 
      select(species, AUC, AUC.lower=.lower,AUC.upper=.upper)
    )|>
  left_join(occ_mfull$occ |> select(species,occurrence_obs)) |>
  mutate(species = paste0("*", species, "*") |>
    str_replace("_", " ")) |>
  mutate(species = fct_relevel(as.factor(species), rev(get_taxa_name(p_tree))))

p_tjurD <- ggplot(fitmetrics) +
  geom_vline(xintercept = c(tjur_CVfull$tjurD_avg$mean_D.lower), linetype = 2) +
  geom_vline(xintercept = c(tjur_CVfull$tjurD_avg$mean_D.upper), linetype = 2) +
  geom_segment(aes(y = species, x = D.lower, xend = D.upper, col = is_non_zero), col = "orange", linewidth = 3) +
  geom_point(aes(y = species, x = TjurD)) +
  scale_y_discrete(name = "") +
  scale_x_continuous(name = "Tjur's *D*") +
  theme_bw() +
  theme(axis.text.y = element_markdown(), axis.title.x = element_markdown())

p_auc <- ggplot(fitmetrics) +
  geom_segment(aes(y = species, x = AUC.lower, xend = AUC.upper), col = "orange", linewidth = 3) +
  geom_segment(aes(y = as.numeric(species)-0.5, yend = as.numeric(species)+0.5,
                   x = occurrence_obs, xend= occurrence_obs)) +
  geom_point(aes(y = species, x = AUC)) +
  scale_y_discrete(name = "") +
  scale_x_continuous(name = "AUC-PR") +
  theme_bw() +
  theme(axis.text.y = element_markdown(), axis.title.x = element_markdown())

p_perf <- (p_tree | p_tjurD|p_auc) + plot_layout(widths = c(0.12, 0.35,0.35),axes = "collect")
```


```{r save-perfplot}
ggsave(filename = here("plot_performance.pdf"), plot = p_perf, device = cairo_pdf, width = 8, height = 6.5)
```

### logOR of AUC-PR vs random baseline

the random baseline for AUC-PR varies between species, as it is the observed prevalence. We can attempt to standardise by looking at the logit(AUC) - logit(prevalence) values

```{r plot-logOR-auc}
p_logORauc  <- ggplot(fitmetrics) +
  geom_segment(aes(y = species, x = qlogis(AUC.lower)-qlogis(occurrence_obs), 
                   xend = qlogis(AUC.upper)-qlogis(occurrence_obs)), col = "orange", linewidth = 3) +
  geom_point(aes(y = species, x = qlogis(AUC)-qlogis(occurrence_obs))) +
  scale_y_discrete(name = "") +
  scale_x_continuous(name = "AUC-PR") +
  theme_bw() +
  theme(axis.text.y = element_markdown(), axis.title.x = element_markdown())

(p_tree | p_logORauc) + plot_layout(widths = c(0.25,0.75))
```


## 3C - variance partitioning

`Hmsc` provides a way to partition the variance of the "explained" part into its different components (although there is here no easy way to extract posterior uncertainty). let's get it, clean it, and plot it

```{r getting-varpart}
varpart <- computeVariancePartitioning(mfull)$vals |>
  as.data.frame()

varpart$var <- rownames(varpart)

varpart <- as_tibble(varpart) |>
  pivot_longer(-var, values_to = "VC", names_to = "species") |>
  mutate(species = paste0("*", species, "*") |>
    str_replace("_", " ")) |>
  mutate(species = fct_relevel(as.factor(species), rev(get_taxa_name(p_tree)))) |>
  mutate(var = case_when(
    var == "district" ~ "District",
    var == "mt_stat_50_scaled" ~ "Moran's *I*",
    var == "proportion_50_scaled" ~ "P%",
    var == "I(proportion_50_scaled^2)" ~ "P%^2^",
    var == "vitalityF" ~ "Vitality",
    var == "Random: sample_ID" ~ "Random effects (sample)",
    TRUE ~ var
  )) |>
  mutate(var = fct_relevel(
    var,
    rev(c("Vitality", "Moran's *I*", "P%", "P%^2^", "District", "Random effects (sample)"))
  )) |>
  mutate(VCtype = case_when(
    var %in% c("Moran's *I*", "P%", "P%^2^", "Vitality") ~ "Local environmental variables",
    TRUE ~ var
  )) |>
  mutate(VCtype = fct_relevel(
    VCtype,
    rev(c("Local environmental variables", "District", "Random effects (sample)"))
  ))
```

```{r varpart-summary}
varpart |>
  mutate(var = case_when(var == "P%^2^" ~ "P%", T ~ var)) |>
  group_by(var, species) |>
  summarise(VC = sum(VC)) |>
  group_by(var) |>
  summarise(mean = mean(VC), sd = stats::sd(VC)) # a conflict with posterior::sd


varpart |>
  group_by(VCtype, species) |>
  summarise(VC = sum(VC)) |>
  group_by(VCtype) |>
  summarise(mean = mean(VC), sd = stats::sd(VC))
```

For the plot, we pool together all local environmental effects, so that the division local-district-"residual"/random is clearer:

```{r varpart plot}
p_V <- ggplot(varpart) +
  geom_bar(aes(y = species, x = VC * 100, fill = VCtype), stat = "identity") +
  scale_x_continuous("% of variance") +
  scale_y_discrete("") +
  scale_fill_brewer("Component",
    type = "qual",
    breaks = c(
      "Local environmental variables", "District",
      "Random effects (sample)"
    )
  ) +
  guides(fill = guide_legend(nrow = 1)) +
  theme_bw() +
  theme(
    legend.position = "bottom",
    legend.text = element_markdown(),
    axis.text.y = element_markdown()
  )

p_VC <- (p_tree | p_V) + plot_layout(widths = c(0.25, 0.75), guides = "collect") & theme(legend.position = "bottom")
```


```{r save-varpart-plot}
ggsave(filename = here("plots","plot_variance_comps.pdf"), plot = p_VC, device = cairo_pdf, width = 7, height = 6.5)
```

## 3D - Model coefficients plots

### Local and district niches (Beta coefficients)

We first start by estimating the average niche coefficients across all Arthropods, all Molluscs, all species by averaging the species -level coefficients, so we can plot both the averages and the species-level values

```{r averaged-betas}
species_groups <- tibble(species = colnames(mfull$Y)) |>
  mutate(group = case_when(
    species %in% c("Cochlicella_acuta", "Cochlicella_barbara", "Pupilla_muscorum", "Theba_pisana", "Xeroplexa_intersecta") ~ "Mollusca",
    TRUE ~ "Arthropoda"
  ))

betas_grouped <- HMSCgrouped_summary(mfull, species_groups) |>
  mutate(group = fct_recode(group,
    `Average effect across all species` = "overall",
    `\\- across Mollusca` = "Mollusca",
    `\\- across Arthropoda` = "Arthropoda"
  )) |>
  mutate(group = fct_relevel(group, "\\- across Arthropoda", after = 1)) |>
  rename(mean = "value", `q2.5` = ".lower", `q97.5` = ".upper")
```

Then we get the actual species-level niches also:

```{r betas}
betas <- summary.mfull |>
  filter(parameter_type == "Beta") |>
  mutate(variable = str_remove_all(variable, "\\([:alpha:][:digit:]+\\)")) |>
  mutate(
    coef = str_split_fixed(variable, " , ", 2)[, 1],
    species = str_split_fixed(variable, " , ", 2)[, 2], .after = 1
  ) |>
  mutate(species = str_remove_all(species, " \\]")) |>
  mutate(species = str_replace_all(species, "_", " ")) |>
  mutate(species = paste0("*", species, "*")) |>
  mutate(coef = str_remove_all(coef, "B\\[")) |>
  mutate(is_non_zero = sign(q2.5) == sign(q97.5))
```


#### district effects

```{r p-beta-district-grouped}
p_beta_district_grouped <- betas_grouped |>
  mutate(is_non_zero = sign(q2.5) == sign(q97.5)) |>
  filter(str_detect(coef, "district")) |>
  mutate(coef = str_remove(coef, "district")) |>
  ggplot() +
  geom_segment(aes(y = group, x = q2.5, xend = q97.5, col = is_non_zero), linewidth = 3) +
  geom_point(aes(y = group, x = mean, fill = is_non_zero), pch = 21) +
  scale_y_discrete(name = "") +
  scale_colour_manual(name = "CI95 ≠ 0?", values = c(`FALSE` = "grey", `TRUE` = "orange")) +
  scale_fill_manual(name = "CI95 ≠ 0?", values = c(`FALSE` = "grey", `TRUE` = "orange")) +
  scale_x_continuous("Posterior coefficient (mean and 95% credible interval)") +
  geom_vline(xintercept = 0, linetype = 2) +
  facet_grid(cols = vars(coef)) +
  theme_bw() +
  theme(axis.text.y = element_markdown()) +
  coord_cartesian(xlim = c(-5, 2))
```

```{r p-beta-district}
betas_district <- betas |>
  filter(str_detect(coef, "district")) |>
  mutate(coef = str_remove(coef, "district")) |>
  mutate(species = fct_relevel(as.factor(species), rev(get_taxa_name(p_tree))))
## needs to be reverse order because of how usual ggplot plots factors on y (bottom to top)

p_beta_district <- ggplot(betas_district) +
  geom_segment(aes(y = species, x = q2.5, xend = q97.5, col = is_non_zero), linewidth = 3) +
  geom_point(aes(y = species, x = mean, fill = is_non_zero), pch = 21) +
  scale_y_discrete(name = "") +
  scale_colour_manual(name = "CI95 ≠ 0?", values = c(`FALSE` = "grey", `TRUE` = "orange")) +
  scale_fill_manual(name = "CI95 ≠ 0?", values = c(`FALSE` = "grey", `TRUE` = "orange")) +
  scale_x_continuous("") +
  geom_vline(xintercept = 0, linetype = 2) +
  facet_grid(cols = vars(coef)) +
  coord_cartesian(xlim = c(-5, 2)) +
  ggtitle(label = "District-level contrasts (vs. reference level: Flemish dunes)") +
  theme_bw() +
  theme(axis.text.y = element_markdown())
```


```{r layout-beta-district}
layout <- "
AB
#C
"
p_beta1 <- (p_tree + p_beta_district + p_beta_district_grouped) +
  plot_layout(
    design = layout,
    widths = c(0.1, 0.9), heights = c(0.85, 0.15), guides = "collect"
  )
```


```{r save-beta-district}
ggsave(filename = here("plots","plot_beta_district.pdf"), 
       plot = p_beta1, device = cairo_pdf, width = 10, height = 8)
```

#### local niche effects

```{r p-beta-local-grouped}
p_local_grouped <- betas_grouped |>
  filter(!str_detect(coef, "district")) |>
  filter(coef != "(Intercept)") |>
  mutate(is_non_zero = sign(q2.5) == sign(q97.5)) |>
  mutate(coef = case_when(
    coef == "mt_stat_50_scaled" ~ "Moran's *I*",
    coef == "proportion_50_scaled" ~ "P% ",
    coef == "I(proportion_50_scaled^2)" ~ "P%^2^",
    coef == "vitalityF0_1" ~ "Vitality < 2 (vs. =4)",
    coef == "vitalityF2" ~ "Vitality = 2 (vs. =4)",
    coef == "vitalityF3" ~ "Vitality = 3 (vs. = 4)",
    TRUE ~ coef
  )) |>
  ggplot() +
  geom_segment(aes(y = group, x = q2.5, xend = q97.5, col = is_non_zero), linewidth = 3) +
  geom_point(aes(y = group, x = mean, fill = is_non_zero), pch = 21) +
  scale_y_discrete(name = "") +
  scale_colour_manual(name = "CI95 ≠ 0?", values = c(`FALSE` = "grey", `TRUE` = "orange")) +
  scale_fill_manual(name = "CI95 ≠ 0?", values = c(`FALSE` = "grey", `TRUE` = "orange")) +
  scale_x_continuous("Posterior coefficient (mean and 95% credible interval)") +
  geom_vline(xintercept = 0, linetype = 2) +
  facet_grid(cols = vars(coef)) +
  theme_bw() +
  theme(
    axis.text.y = element_markdown(),
    strip.text = element_markdown()
  ) +
  coord_cartesian(xlim = c(-2, 2))
```


```{r p-beta-local}
betas_local <- betas |>
  filter(!str_detect(coef, "district")) |>
  filter(coef != "(Intercept)") |>
  mutate(species = fct_relevel(as.factor(species), rev(get_taxa_name(p_tree)))) |>
  mutate(coef = case_when(
    coef == "mt_stat_50_scaled" ~ "Moran's *I*",
    coef == "proportion_50_scaled" ~ "P% ",
    coef == "I(proportion_50_scaled^2)" ~ "P%^2^",
    coef == "vitalityF0_1" ~ "Vitality < 2 (vs. =4)",
    coef == "vitalityF2" ~ "Vitality = 2 (vs. =4)",
    coef == "vitalityF3" ~ "Vitality = 3 (vs. = 4)",
    TRUE ~ coef
  ))

p_local <- ggplot(betas_local) +
  geom_segment(aes(y = species, x = q2.5, xend = q97.5, col = is_non_zero), linewidth = 3) +
  geom_point(aes(y = species, x = mean, fill = is_non_zero), pch = 21) +
  scale_y_discrete(name = "") +
  scale_colour_manual(name = "CI95 ≠ 0?", values = c(`FALSE` = "grey", `TRUE` = "orange")) +
  scale_fill_manual(name = "CI95 ≠ 0?", values = c(`FALSE` = "grey", `TRUE` = "orange")) +
  scale_x_continuous("Posterior coefficient (mean and 95% credible interval)") +
  geom_vline(xintercept = 0, linetype = 2) +
  facet_grid(cols = vars(coef)) +
  ggtitle(label = "Local environmental effects") +
  theme_bw() +
  theme(
    axis.text.y = element_markdown(),
    strip.text = element_markdown()
  ) +
  coord_cartesian(xlim = c(-2, 2))
```


```{r layout-beta-local}
layout <- "
AB
#C
"
p_beta2 <- (p_tree + p_local + p_local_grouped) +
  plot_layout(
    design = layout,
    widths = c(0.1, 0.9), heights = c(0.85, 0.15), guides = "collect"
  )
```


```{r save-beta-local}
ggsave(filename = here("data","plot_beta_local.pdf"), 
       plot = p_beta2, device = cairo_pdf, width = 12, height = 8)
```

### Phylogenetic signal of species niches (Rho coefficient)

```{r phylosignal}
summary.mfull |>
  filter(parameter_type == "Rho")
```


### Traits effects on species niches (Gamma coefficients)

```{r get-gammas}
gammas <- summary.mfull |>
  filter(parameter_type == "Gamma") |>
  mutate(variable = str_remove_all(variable, "\\([:alpha:][:digit:]+\\)")) |>
  mutate(
    coef = str_split_fixed(variable, " , ", 2)[, 1],
    trait = str_split_fixed(variable, " , ", 2)[, 2], .after = 1
  ) |>
  mutate(trait = str_remove_all(trait, " \\]")) |>
  mutate(coef = str_remove_all(coef, "G\\[")) |>
  mutate(is_non_zero = sign(q2.5) == sign(q97.5)) |>
  mutate(trait = case_when(
    trait == "log10size_scaled" ~ "log<sub>10</sub>(body size)",
    trait == "trophic_level_adultOmnivore" ~ "Omnivore (vs Herbivore)",
    trait == "trophic_level_adultDetritivore" ~ "Detritivore (vs Herbivore)",
    trait == "trophic_level_adultPredator" ~ "Predator (vs Herbivore)",
    TRUE ~ trait
  )) |>
  filter(trait != "(Intercept)") |>
  mutate(trait = fct_relevel(trait, "log<sub>10</sub>(body size)", after = 0))
```

```{r p-gamma-district}
gammas_district <- gammas |>
  filter(str_detect(coef, "district")) |>
  mutate(coef = str_remove(coef, "district"))

p_gamma1 <- ggplot(gammas_district) +
  geom_segment(aes(y = trait, x = q2.5, xend = q97.5, col = is_non_zero), linewidth = 3) +
  geom_point(aes(y = trait, x = mean, fill = is_non_zero), pch = 21) +
  scale_y_discrete(name = "") +
  scale_colour_manual(name = "CI95 ≠ 0?", values = c(`FALSE` = "grey", `TRUE` = "orange")) +
  scale_fill_manual(name = "CI95 ≠ 0?", values = c(`FALSE` = "grey", `TRUE` = "orange")) +
  scale_x_continuous("Posterior coefficient (mean and 95% credible interval)") +
  geom_vline(xintercept = 0, linetype = 2) +
  facet_grid(cols = vars(coef)) +
  ggtitle(label = "District-level contrasts (vs. reference level: Flemish dunes)") +
  theme_bw() +
  theme(axis.text.y = element_markdown())
```

```{r save-gamma-district}
ggsave(filename = here("plots","plot_gamma_district.pdf"), 
       plot = p_gamma1, device = cairo_pdf, width = 8, height = 6)
```

```{r p-gamma-local}
gammas_local <- gammas |>
  filter(!str_detect(coef, "district")) |>
  filter(coef != "(Intercept)") |>
  mutate(coef = case_when(
    coef == "mt_stat_50_scaled" ~ "Moran's *I*",
    coef == "proportion_50_scaled" ~ "P% ",
    coef == "I(proportion_50_scaled^2)" ~ "P%^2^",
    coef == "vitalityF0_1" ~ "Vitality < 2 (vs. =4)",
    coef == "vitalityF2" ~ "Vitality = 2 (vs. =4)",
    coef == "vitalityF3" ~ "Vitality = 3 (vs. = 4)",
    TRUE ~ coef
  ))

p_gamma2 <- ggplot(gammas_local) +
  geom_segment(aes(y = trait, x = q2.5, xend = q97.5, col = is_non_zero), linewidth = 3) +
  geom_point(aes(y = trait, x = mean, fill = is_non_zero), pch = 21) +
  scale_y_discrete(name = "") +
  scale_colour_manual(name = "CI95 ≠ 0?", values = c(`FALSE` = "grey", `TRUE` = "orange")) +
  scale_fill_manual(name = "CI95 ≠ 0?", values = c(`FALSE` = "grey", `TRUE` = "orange")) +
  scale_x_continuous("Posterior coefficient (mean and 95% credible interval)") +
  geom_vline(xintercept = 0, linetype = 2) +
  facet_grid(cols = vars(coef)) +
  ggtitle(label = "Local environmental effects") +
  theme_bw() +
  theme(
    axis.text.y = element_markdown(),
    strip.text = element_markdown()
  )
```

```{r save-gamma-local}
ggsave(filename = here("plots","plot_gamma_local.pdf"), 
       plot = p_gamma2, device = cairo_pdf, width = 8, height = 6)
```


### Correlations between species

Here we will make a plot illustrating the "residual" correlations between species, those not explained by shared responses to environmental parameters included in models. The covariances are in the `Omega` parameters in the HMSC object, so we start by extracting and cleaning those.
They are in long format (one row = one species pair), we also put both the posterior means, and a logical saying whether the 95% Ci includes 0 or not, in wide format:

```{r make-HSMCcors}
HMSC_cors <- summary.mfull |>
  filter(parameter_type == "Omega" & index == 1) |>
  mutate(is_nonzero = sign(q2.5) == sign(q97.5)) |>
  select(variable, mean, is_nonzero) |>
  mutate(variable = str_remove(variable, pattern = "Omega1\\[")) |>
  mutate(variable = str_remove(variable, "\\]")) |>
  mutate(variable = str_remove_all(variable, "\\(S[:digit:]+\\)")) |>
  mutate(variable = str_remove_all(variable, " ")) |>
  mutate(
    species1 = str_split_fixed(variable, ",", 2)[, 1],
    species2 = str_split_fixed(variable, ",", 2)[, 2]
  ) |>
  select(mean, is_nonzero, species1, species2) |>
  mutate(
    species1 = paste0("*", str_replace(species1, "_", " "), "*"),
    species2 = paste0("*", str_replace(species2, "_", " "), "*")
  )

## the mean covariance matrix
cc <- HMSC_cors |>
  select(mean, species1, species2) |>
  pivot_wider(names_from = species2, values_from = mean)

covmat <- as.matrix(cc[, -1])
rownames(covmat) <- cc$species1

## the outcome of comparing the CI to zero
pp <- HMSC_cors |>
  mutate(p.mat = as.numeric(!is_nonzero)) |>
  select(p.mat, species1, species2) |>
  pivot_wider(names_from = species2, values_from = p.mat)

pmat <- as.matrix(pp[, -1])
rownames(pmat) <- pp$species1
```

```{r plot-HMSCcors}
p_cors <- ggcorrplot(cov2cor(covmat),
  p.mat = pmat,
  insig = "blank",
  hc.order = TRUE,
  hc.method = "average",
  tl.cex = 9,
  colors = c("#5e3c99", "white", "#e66101"),
  tl.srt = 90,
  legend.title = "Correlation"
) +
  scale_x_discrete(position = "top") +
  theme(
    axis.text = element_markdown(),
    axis.text.x = element_text(hjust = 0)
  )
```

```{r save-plot-rescors}
ggsave(filename = here("plots","rescor_matrix.pdf"), plot = p_cors, device = cairo_pdf, width = 8, height = 8)
```

```{r quick-cor-check}
# a quick check on how the correlations that are different from 0 are distributed,
# since their mean posterior values seem quite grouped/homogenous on the above plot

p_corcheck <- tibble(cor=c(cov2cor(covmat)),p=c(pmat),lower.tri=c(lower.tri(covmat))) |> 
  filter(lower.tri) |> # avoid duplicates + removes the main diagonal which is obviously all 1s
  mutate(p = (p==0)) |> 
  ggplot()+
  geom_density(aes(abs(cor),fill=factor(p)),alpha=0.5)+
  scale_x_continuous("absolute value of posterior mean correlation")+
  scale_fill_manual(name = "CI95 ≠ 0?", values = c(`TRUE` = "orange",`FALSE` = "grey"))+
  theme_bw()
```

```{r save-plot-rescors}
ggsave(filename = here("plots","Splot_correlation_magnitude.pdf"), plot = p_corcheck, device = cairo_pdf, width = 6, height = 6)
```

## 3E - supplementary : spatial correlation in site loadings

We were not able to get to converge a model where the site random effects are fully spatially explicit (following ) (not shown in code).

To nonetheless explore whether there is a spatial signal in the correlation matrix seen above, we extract the site loadings on the underlying latent factors and examine whether they present a spatial pattern.

We first extract the full posterior samples (as opposed to the summaries obtained through `HMSCsummary()` earlier in script):

```{r extract-site-loadings}
HMSCcoda <- convertToCodaObject(mfull)

params <- enframe(HMSCcoda, name = "parameter_type")

Es <- filter(params, parameter_type == "Eta") |> unnest(value)


set.seed(42)

Etas <- Es$value[[1]] |> 
  as_draws_df()|>
  pivot_longer(-c(.iteration, .chain, .draw)) |>
  mutate(variable = str_remove(name, "Eta1\\[")) |>
  mutate(variable = str_remove(variable, "\\]")) |>
  mutate(
    sample_ID = str_split_fixed(variable, pattern = ", factor", 2)[, 1],
    factor = str_split_fixed(variable, pattern = ", factor", 2)[, 2]
  ) |>
  left_join(raw_envt |>
    select(sample_ID, X, Y) |>
    mutate(
      X = X + rnorm(length(X), 0, 10^-15),
      Y = Y + rnorm(length(Y), 0, 10^-15)
    )) |>
  ## there are a few plots in the same transect with identical latlon (I suspect it's very close points and GPS imprecision)
  ## we add some minuscule jitter to avoid issues with 0 values
  group_by(.chain, .iteration, .draw, factor) |>
  nest()
```

We end up with a grouped tibble with a list-column `data` that contains for each posterior sample and each latent factor, a table with the coordinates of each sites and their predicted values on the latent factor

For each posterior sample x latent factor, we then estimate the correlogram (by increments of 5 km)...

```{r make-correlograms}
starttime <- Sys.time()
Eta_correlogs <- Etas |>
  mutate(correl = map(
    .x = data,
    .f = function(tab = .x) {
      correlogram <- correlog(
        x = tab$X, y = tab$Y,
        z = tab$value,
        resamp = 0,
        latlon = TRUE,
        increment = 5
      )

      output <- tibble(
        meandist = correlogram$mean.of.class,
        correlation = correlogram$correlation,
        npairs = correlogram$n
      )
      return(output)
    }
  ))
endtime <- Sys.time()
endtime - starttime

# takes about 1-2 hours
```

... which we then plot, using the posteriors to show the uncertainty:

```{r plot-correlograms}
p_correlog <- Eta_correlogs |>
  select(factor, correl) |>
  unnest(cols = correl) |>
  mutate(
    distbin_min = floor(meandist / 5) * 5,
    distbin_max = ceiling(meandist / 5) * 5
  ) |>
  mutate(distbin_center = (distbin_min + distbin_max) / 2) |>
  ggplot() +
  stat_lineribbon(aes(distbin_center, correlation),
    .width = 0.95, fill = "darkgrey", linewidth = 0.75,
    point_interval = "mean_qi"
  ) +
  stat_pointinterval(aes(distbin_center, correlation),
    .width = c(0),
    interval_colour = "darkgrey",
    point_interval = "mean_qi"
  ) +
  geom_hline(yintercept = 0, linetype = 2) +
  scale_x_log10("distance between sites (km, binned in 5 km groups)") +
  theme_bw() +
  facet_wrap(~ paste0("site loadings on latent factor #", factor))
```

```{r save-plot-correlog}
ggsave(filename = here("plots","Splot_correlog_5km.pdf"), plot = p_correlog, device = cairo_pdf, width = 5, height = 5)
```